<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>ECE 5760: Playing Card Recognition</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/scrolling-nav.css" rel="stylesheet">

  </head>

  <body id="page-top">

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
      <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="#page-top">ECE 5760: Playing Card Recognition</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#intro">Introduction</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#overview">Overview</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#implementation">Implementation</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#testing">Testing</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#results">Results</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#references">References</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#appendix-a">Appendices</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#ack">Acknowledgements</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <header style="background-color: #009520" class="text-white">
      <div class="container text-center">
        <h1>ECE 5760: Playing Card Recognition</h1>
        <p class="lead">Albert Chu (ac2369), Dan Edens (de229), Vaidehi Garg (vg254)</p>
      </div>
    </header>

    <section id="intro">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Introduction</h2>
            <p class="lead">For our final project for ECE 5760, we drew inspiration from <a href="https://hackaday.io/project/27639-rainman-20-blackjack-robot">this project</a>, and built a system that recognizes alphanumeric characters on playing cards -- but without the use of OpenCV. The project was intended to be the first step towards implementing an automated blackjack player on a DE1-SoC board. We picked this project because we wanted to combine the unique abilities of the DE1-SoC board, and implement a project that involved computer vision, parallelization, and user interaction.</p>
            <p class="lead">Our project implementation was distributed over both the FPGA and the HPS, which communicated with each other using parallel I/O ports instantiated in Qsys. We implemented the project in stages, starting with a MATLAB implementation, and then porting the logic over to C, and finally implementing certain parts in Verilog. This helped in testing, debugging, and benchmarking our implementation.</p>

          </div>
        </div>
      </div>
    </section>

    <section id="overview" class="bg-light">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Overview</h2>
            <p class="lead">Our project uses the FPGA and the HPS on the DE1-SoC board to implement a character recognition algorithm for playing cards. Apart from the board, our hardware consisted of an NTSC bullet camera facing downwards onto a black background, and a wooden platform onto which the camera was mounted. The cards we used were larger print playing cards, since the camera resolution was low, and we needed larger characters to implement accurate character recognition.</p>
            <p class="lead">The video stream from the camera was input into the FPGA and then stored in memory in the form of image captures. This memory was accessed by the VGA subsystem for display on a VGA screen, and also by the FPGA and the HPS for analysis of the image captured. The FPGA performs contour traversal on the image to find the outline of the card, and detects its corners. This data is sent over to the HPS along with the image itself. The HPS uses this data to rotate the image, extract the symbol on the top left corner, and perform symbol recognition on it. The user interface was implemented on the console using the HPS.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="implementation">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Implementation</h2>
            <p class="lead"></p>
            <h4>FPGA</h4>
            <p class="lead">The FPGA side of the project begins with receiving a live video from an NTSC bullet camera (obtained from Bruce's lab). These cameras are easy to use with the DE1-SoC board and are well documented on the course website and past projects. However, they do not have very high resolution (320x240 pixels), and the lens introduces some fishbowl effect, which places restrictions on the camera's capabilities. In order to get an adequately clear picture for our algorithm, we needed to place the camera fairly close to the card, which limited the number of cards we could reliably scan at the same time. For the project, we restricted ourselves to scanning and recognizing a single card at a time. The Verilog code contains two state machines that run concurrently to implement the system.</p>
            <p class="lead">The first state machine is the video stream state machine, which reads every pixel of the video feed at a 50 MHz clock. The pixels are written to multiple locations, including VGA memory (through the bus-master), as well as ten dual-clocked M10K blocks defined in Verilog. We store 10 copies of each frame -- one to send to the HPS over a PIO port, and another nine copies that are used to perform contour traversal. This is because our contour traversal algorithm (discussed later in this section) requires reading the eight neighboring pixels for each location. Since we had memory resources to spare, we decided to perform this step in a single clock cycle by reading from 8 separate M10K blocks. The image copies are stored as an array of 76800 (320x240) 8-bit RGB values. Prior to storage, the RGB pixel values were thresholded to ensure that the image was black and white, i.e. any non-white pixels were converted to black.</p>
            <p class="lead">A second state machine performs contour traversal and corner detection in parallel, also at 50 MHz. It resets when it receives a signal from the video state machine that a new image has been captured. In State 0, it initializes certain registers using in the algorithm, and sets the read address to read the first pixel of the image. Then, it traverses the stored image one pixel at a time, searching for the first white pixel (which indicates that the playing card has been found). To avoid stray white pixels in the image being recognized as the playing card, it checks to make sure that the pixel in consideration is indeed surrounded by at least four other white pixels (which would be true for any white pixel on the playing cards). It does this by concurrently reading the eight neighbors of the pixel in consideration from the M10K blocks.</p>
            <p class="lead">Once the first pixel of the card has been identified, the state machine considers the neighboring pixels once again and based on their values, decides on one of eight directions to traverse the contour in. It then draws the contour onto a blank M10K block by writing white pixels at contour locations. The data in this contour M10K block is shared with the HPS, and acts as a canvas onto which we can plot our analysis of the live image. It also updates the address for the next pixel to read, and updates the variables that store the coordinates for the four corners of the card. This is done by simply comparing the existing corner coordinates with the coordinates of the current pixel. A more interesting version of corner detection, that uses the second derivative of the contour slope at any given point was implemented on HPS, but was challenging to implement in Verilog.</p>
            <p class="lead">After the direction to traverse in has been decided and the corners updated, the row and column values are updated on the basis of the selected direction. These determine the coordinates of the next pixel of the card contour. The state machine also checks to ensure that it stops traversing the card contour once it reaches close to the first contour pixel (or alternatively, gets to 360 contour pixels). If the contour is not complete, the state machine returns to state 2, increments the contour counter, and continues to traverse. Otherwise, if it meets the conditions to indicate that contour traversing is complete, the contour pixel counter is reset, the contour M10K is reset, and the corner locations are written to memory by writing the value 2. This differentiates them from black pixels (0) and white pixels (1). Finally, it informs the HPS through a PIO port that corners are available, and clears the memory.</p>
            
            <h4>Qsys Setup</h4>
            <p class="lead">garbage</p>
            <h4>HPS</h4>
            <p class="lead">garbage</p>
          </div>
        </div>
      </div>
    </section>

    <section id="testing" class="bg-light">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Testing</h2>
            <p class="lead">Add details about testing here.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="results">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Results & Analysis</h2>
            <p class="lead">Add details about results here.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="references" class="bg-light">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>References</h2>
            <p class="lead"><a href="https://hackaday.io/project/27639-rainman-20-blackjack-robot">[1] Blackjack robot on RaspberryPi using OpenCV.</a></p>
            <p class="lead"><a href="https://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/HPS_peripherials/univ_pgm_computer.index.html">[2] Converting Video to SDRAM 640x480 8-bit color.</a></p>
            
            <p class="lead"><a href="http://www.mdpi.com/1424-8220/16/3/353/htm">[3] Radial sweep contour following algorithm.</a></p>
          </div>
        </div>
      </div>
    </section>

    <section id="appendix-a">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Appendix A: Permissions</h2>
            <p class="lead">This group approves this report for inclusion on the course website.</p>
            <p class="lead">This group approves the video for inclusion on the course YouTube channel.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="appendix-b" class="bg-light">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Appendix B: Source Code</h2>
            <p class="lead"><a href="https://drive.google.com/drive/folders/1sK_ML3JU6pXgMpZGXnHiQhz8ghLLDy2R?usp=sharing">FPGA Project and C File.</a></p>
          </div>
        </div>
      </div>
    </section>

    <section id="appendix-c">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Appendix C: Work Distribution</h2>
            <p class="lead">All group members contributed to all parts of the project, including Verilog logic, HPS code, debugging, and the final report. Dan performed the initial implementation in MATLAB, and helped implement the HPS and Verilog versions. Albert worked on the implementation in C and the user interface. Vaidehi helped port the implementation over from C to Verilog, and debug the HPS and Verilog versions.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="ack">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
            <h2>Acknowledgements</h2>
            <p class="lead">We would like to thank Prof. Bruce Land, and TAs Mark Zhao and Claire Chen for their help throughout the course.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Footer -->
    <footer class="py-5 bg-dark">
      <div class="container">
        <p class="m-0 text-center text-white">Copyright &copy; Cornell University, ECE 5760 (Spring 2018)</p>
      </div>
      <!-- /.container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Custom JavaScript for this theme -->
    <script src="js/scrolling-nav.js"></script>

  </body>

</html>
